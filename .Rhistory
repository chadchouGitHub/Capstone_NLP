for(i in 1:B){
hf <- sample(chowPopulation,N)
se=sd(hf)/sqrt(N)
interval <- c(mean(hf)-Q*se, mean(hf)+Q*se )
## covered is logical vector to check the interval with real mean. to see if real mean
## cover within interval.
covered<-mean(chowPopulation)<= interval[2] & mean(chowPopulation)>=interval[1]
print (covered) ## this line I use to see what the covered have in the value.
color <- ifelse(covered,1,2) # use ifelse() to decide the color value 1 for ture
## 2 for false
print(color) ## this I use to see waht is the color value "1" or "2"
lines( c(30,13,24,3), c(i,2,13,30),col=color) ## lines() is draw a line between points
}
B <- 1
mypar2(1,1)
plot(mean(chowPopulation)+c(-7,7),c(1,1),type="n",
xlab="weight",ylab="interval",ylim=c(1,B))
abline(v=mean(chowPopulation))
for(i in 1:B){
hf <- sample(chowPopulation,N)
se=sd(hf)/sqrt(N)
interval <- c(mean(hf)-Q*se, mean(hf)+Q*se )
## covered is logical vector to check the interval with real mean. to see if real mean
## cover within interval.
covered<-mean(chowPopulation)<= interval[2] & mean(chowPopulation)>=interval[1]
print (covered) ## this line I use to see what the covered have in the value.
color <- ifelse(covered,1,2) # use ifelse() to decide the color value 1 for ture
## 2 for false
print(color) ## this I use to see waht is the color value "1" or "2"
lines( c(30,18,24,3), c(i,i,13,30),col=color) ## lines() is draw a line between points
}
B <- 1
mypar2(1,1)
plot(mean(chowPopulation)+c(-7,7),c(1,1),type="n",
xlab="weight",ylab="interval",ylim=c(1,B))
abline(v=mean(chowPopulation))
for(i in 1:B){
hf <- sample(chowPopulation,N)
se=sd(hf)/sqrt(N)
interval <- c(mean(hf)-Q*se, mean(hf)+Q*se )
## covered is logical vector to check the interval with real mean. to see if real mean
## cover within interval.
covered<-mean(chowPopulation)<= interval[2] & mean(chowPopulation)>=interval[1]
print (covered) ## this line I use to see what the covered have in the value.
color <- ifelse(covered,1,2) # use ifelse() to decide the color value 1 for ture
## 2 for false
print(color) ## this I use to see waht is the color value "1" or "2"
lines( c(30,18,24,1.4), c(i,i,1.3,30),col=color) ## lines() is draw a line between points
}
B <- 1
mypar2(1,1)
plot(mean(chowPopulation)+c(-7,7),c(1,1),type="n",
xlab="weight",ylab="interval",ylim=c(1,B))
abline(v=mean(chowPopulation))
for(i in 1:B){
hf <- sample(chowPopulation,N)
se=sd(hf)/sqrt(N)
interval <- c(mean(hf)-Q*se, mean(hf)+Q*se )
## covered is logical vector to check the interval with real mean. to see if real mean
## cover within interval.
covered<-mean(chowPopulation)<= interval[2] & mean(chowPopulation)>=interval[1]
print (covered) ## this line I use to see what the covered have in the value.
color <- ifelse(covered,1,2) # use ifelse() to decide the color value 1 for ture
## 2 for false
print(color) ## this I use to see waht is the color value "1" or "2"
lines( c(30,18,24,30), c(i,i,1.3,1.4),col=color) ## lines() is draw a line between points
}
B <- 100
mypar2(1,1)
plot(mean(chowPopulation)+c(-7,7),c(1,1),type="n",
xlab="weight",ylab="interval",ylim=c(1,B))
abline(v=mean(chowPopulation))
for(i in 1:B){
hf <- sample(chowPopulation,N)
se=sd(hf)/sqrt(N)
interval <- c(mean(hf)-Q*se, mean(hf)+Q*se )
## covered is logical vector to check the interval with real mean. to see if real mean
## cover within interval.
covered<-mean(chowPopulation)<= interval[2] & mean(chowPopulation)>=interval[1]
print (covered) ## this line I use to see what the covered have in the value.
color <- ifelse(covered,1,2) # use ifelse() to decide the color value 1 for ture
## 2 for false
print(color) ## this I use to see waht is the color value "1" or "2"
lines( c(30,18,24,30), c(i,i,1.3,i),col=color) ## lines() is draw a line between points
}
library(rafalib)
B <- 10
mypar2(1,1)
plot(mean(chowPopulation)+c(-7,7),c(1,1),type="n",
xlab="weight",ylab="interval",ylim=c(1,B))
abline(v=mean(chowPopulation))
for(i in 1:B){
hf <- sample(chowPopulation,N)
se=sd(hf)/sqrt(N)
interval <- c(mean(hf)-Q*se, mean(hf)+Q*se )
## covered is logical vector to check the interval with real mean. to see if real mean
## cover within interval.
covered<-mean(chowPopulation)<= interval[2] & mean(chowPopulation)>=interval[1]
print (covered) ## this line I use to see what the covered have in the value.
color <- ifelse(covered,1,2) # use ifelse() to decide the color value 1 for ture
## 2 for false
print(color) ## this I use to see waht is the color value "1" or "2"
lines( c(30,18,24,30), c(i,i,1.3,i),col=color) ## lines() is draw a line between points
}
B <- 10
mypar2(1,1)
plot(mean(chowPopulation)+c(-7,7),c(1,1),type="n",
xlab="weight",ylab="interval",ylim=c(1,B))
abline(v=mean(chowPopulation))
for(i in 1:B){
hf <- sample(chowPopulation,N)
se=sd(hf)/sqrt(N)
interval <- c(mean(hf)-Q*se, mean(hf)+Q*se )
## covered is logical vector to check the interval with real mean. to see if real mean
## cover within interval.
covered<-mean(chowPopulation)<= interval[2] & mean(chowPopulation)>=interval[1]
print (covered) ## this line I use to see what the covered have in the value.
color <- ifelse(covered,1,2) # use ifelse() to decide the color value 1 for ture
## 2 for false
print(color) ## this I use to see waht is the color value "1" or "2"
lines( interval, c(i,i),col=color) ## lines() is draw a line between points
}
library(rafalib)
mypar2()
library(GSE5859Subset)
data(GSE5859Subset) ##this loads the three tables
dim(geneExpression)
head(sampleInfo)
sampleInfo$group
head(geneExpression)
match(sampleInfo$filename,colnames(geneExpression))
head(geneExpressio)
head(geneExpression)
?match
match(sampleInfo$filename,colnames(geneExpression))
colnames(geneExpression)
sampleInfo$filename
dim(geneAnnotation)
head(geneAnnotation)
head(match(geneAnnotation$PROBEID,rownames(geneExpression)))
geneAnnotation$PROBEID
rownames(geneExpression)
library(rafalib)
library(GSE5859Subset)
g <- sampleInfo$group
g
e <- geneExpression[25,]
e
e1<- geneExpression[1,]
e1
head(geneExpression)
e1<- geneExpression[25,1]
e1
e<- geneExpression[25,]
e[g==1]
?qqnorm
mypar2(1,2)
qqnorm(e[g==1])
qqline(e[g==1])
qqnorm(e[g==0])
qqline(e[g==0])
t.test(e[g==1],e[g==0])
?apply
myttest <- function(x) t.test(x[g==1],x[g==0],var.equal=TRUE)$p.value
pvals <- apply(geneExpression,1,myttest)
sum(pvals<0.05)
source("http://www.bioconductor.org/biocLite.R")
biocLite("genefilter")
set.seed(1)
m <- nrow(geneExpression)
n <- ncol(geneExpression)
randomData <- matrix(rnorm(n*m),m,n)
randomData
nullpvals <- apply(randomData,1,myttest)
sum(nullpvals<0.05)
sum(pvals<0.05)
rnorm(n*m)
?rnorm
library(genefilter)
results <- rowttests(geneExpression,factor(g))
max(abs(pvals-results$p))
triWx
triWx <- c("I am your")
triWx
splitTriWx <- split(triWx)
?split
splitTriWx <- strsplit(triWx, split, fixed=FALSE)
triWx <-as.string(c("I am your"))
triWx
triWx <-"I am your"
triWx
splitTriWx <- strsplit(triWx, split, fixed=FALSE)
splitTriWx <- strsplit(triWx, " ")
splitTriWx
splitTriWx[-1]
splitTriWx[length(splitTriWx)]
splitTrixWx[3]
splitTriWx[3]
splitTriWx[[3]]
splitTriWx
triWx <-c("I am your")
triWx
splitTriWx <- strsplit(triWx, " ")
splitTriWx
splitTriWx <- ulist(strsplit(triWx, " "))
splitTriWx <- unlist(strsplit(triWx, " "))
splitTriWx
splitTriWx[length(splitTriWx)]
triWx <-c("I am your father")
triWx
splitTriWx <- unlist(strsplit(triWx, " "))
splitTriWx[length(splitTriWx)]
lastWordF <- function(x){
splitTriWx <- unlist(strsplit(x, " "))
y<- splitTriWx[length(splitTriWx)]
return(y)
}
triWx <-c("I am your father")
triWx
lastWordF(triWx)
library(shiny)
runExample("03_reactivity")
runExample("04_mpg")
runExample("05_sliders")
runExample("06_tabsets")
runExample("07_widgets")
runExample("08_html")
runExample("09_upload")
runExample("10_download")
runExample("11_timer")
setwd("~/Dropbox/Scripts/Capstone_NLP/Capstone_NLP")
shiny::runApp('word-app')
shiny::runApp('word-app')
shiny::runApp('word-app')
shiny::runApp('word-app')
shiny::runApp('word-app')
shiny::runApp('~/word-app')
shiny::runApp('~/word-app')
shiny::runApp('~/word-app')
shiny::runApp('~/word-app')
shiny::runApp('~/word-app')
shiny::runApp('~/word-app')
triTokenF <- function(x,y) {
l <- length(y)
## make a empty df for for loop
if(l>=20){
y <- y[1:10]
l <- 10
}
w<- data.frame(Date=as.Date(character()),
File=character(),
User=character(),
stringsAsFactors=FALSE)
for (i in 1:l)
{
matchWord <- paste(x,y[i]) # put last two words with candidate list word together.
newRows<- subset(triSorted, triToken == matchWord)
w<- rbind(w,newRows)
}
if (nrow(w)>=1){
z <- w[order(w$Ranking,decreasing = F),]
return(z)
}
return(paste(x,y[1]))
}
mytest<- predictW("I am your")
triTokenF <- function(x,y) {
l <- length(y)
## make a empty df for for loop
if(l>=20){
y <- y[1:10]
l <- 10
}
w<- data.frame(Date=as.Date(character()),
File=character(),
User=character(),
stringsAsFactors=FALSE)
for (i in 1:l)
{
matchWord <- paste(x,y[i]) # put last two words with candidate list word together.
newRows<- subset(triSorted, triToken == matchWord)
w<- rbind(w,newRows)
}
if (nrow(w)>=1){
z <- w[order(w$Ranking,decreasing = F),]
return(z)
}
w$triToken <- paste(x,y[1])
return(w)
}
mytest<- predictW("I am your")
triTokenF <- function(x,y) {
l <- length(y)
## make a empty df for for loop
if(l>=20){
y <- y[1:10]
l <- 10
}
w<- data.frame(Date=as.Date(character()),
File=character(),
User=character(),
stringsAsFactors=FALSE)
for (i in 1:l)
{
matchWord <- paste(x,y[i]) # put last two words with candidate list word together.
newRows<- subset(triSorted, triToken == matchWord)
w<- rbind(w,newRows)
}
if (nrow(w)>=1){
z <- w[order(w$Ranking,decreasing = F),]
return(z)
}
w <- w$triToken=paste(x,y[1])
return(w)
}
mytest<- predictW("I am your")
triTokenF <- function(x,y) {
l <- length(y)
## make a empty df for for loop
if(l>=20){
y <- y[1:10]
l <- 10
}
w<- data.frame(Date=as.Date(character()),
File=character(),
User=character(),
stringsAsFactors=FALSE)
for (i in 1:l)
{
matchWord <- paste(x,y[i]) # put last two words with candidate list word together.
newRows<- subset(triSorted, triToken == matchWord)
w<- rbind(w,newRows)
}
if (nrow(w)>=1){
z <- w[order(w$Ranking,decreasing = F),]
return(z)
}
w$triToken <- paste(x,y[1])
return(w)
}
mytest<- predictW("I am your")
triTokenF <- function(x,y) {
l <- length(y)
## make a empty df for for loop
if(l>=20){
y <- y[1:10]
l <- 10
}
w<- data.frame(Date=as.Date(character()),
File=character(),
User=character(),
stringsAsFactors=FALSE)
for (i in 1:l)
{
matchWord <- paste(x,y[i]) # put last two words with candidate list word together.
newRows<- subset(triSorted, triToken == matchWord)
w<- rbind(w,newRows)
}
if (nrow(w)>=1){
z <- w[order(w$Ranking,decreasing = F),]
return(z)
}
return(w)
}
mytest<- predictW("I am your")
mytest<- predictW("your")
mytest<- predictW("your home")
predictW <- function(x){
triWx <-c(x) ## input "I did ya"
triWx<- tolower(triWx)
l<- length(unlist(strsplit(triWx, " ")))
if( l == 1 )
{
lastWordF(triWx)
cList <- candiateF(lastWordF(triWx))
predictW <- cList[1]
}
if(l!=1)
{
lastWordF(triWx)
test2x <- lastTwoWordF(triWx)
cListy <- candiateF(lastWordF(triWx))
test3XYbeta<- triTokenF(test2x,cListy)
z <- as.character(test3XYbeta$triToken)
if(z!=NA){
predict<- z[1]
predictW <- lastWordF(predict)
}
if(z==NA){
predictW <- cListy[1]
}
}
}
return(predictW)
}
predictW <- function(x){
triWx <-c(x) ## input "I did ya"
triWx<- tolower(triWx)
l<- length(unlist(strsplit(triWx, " ")))
if( l == 1 )
{
lastWordF(triWx)
cList <- candiateF(lastWordF(triWx))
predictW <- cList[1]
}
if(l!=1)
{
lastWordF(triWx)
test2x <- lastTwoWordF(triWx)
cListy <- candiateF(lastWordF(triWx))
test3XYbeta<- triTokenF(test2x,cListy)
z <- as.character(test3XYbeta$triToken)
if(z!=NA){
predict<- z[1]
predictW <- lastWordF(predict)
}
if(z==NA){
predictW <- cListy[1]
}
}
return(predictW)
}
mytest<- predictW("your home")
predictW <- function(x){
triWx <-c(x) ## input "I did ya"
triWx<- tolower(triWx)
l<- length(unlist(strsplit(triWx, " ")))
if( l == 1 )
{
lastWordF(triWx)
cList <- candiateF(lastWordF(triWx))
predictW <- cList[1]
}
if(l!=1)
{
lastWordF(triWx)
test2x <- lastTwoWordF(triWx)
cListy <- candiateF(lastWordF(triWx))
test3XYbeta<- triTokenF(test2x,cListy)
z <- as.character(test3XYbeta$triToken)
if(z=!NA){
predict<- z[1]
predictW <- lastWordF(predict)
}
if(z==NA){
predictW <- cListy[1]
}
}
return(predictW)
}
predictW <- function(x){
triWx <-c(x) ## input "I did ya"
triWx<- tolower(triWx)
l<- length(unlist(strsplit(triWx, " ")))
if( l == 1 )
{
lastWordF(triWx)
cList <- candiateF(lastWordF(triWx))
predictW <- cList[1]
}
if(l!=1)
{
lastWordF(triWx)
test2x <- lastTwoWordF(triWx)
cListy <- candiateF(lastWordF(triWx))
test3XYbeta<- triTokenF(test2x,cListy)
z <- as.character(test3XYbeta$triToken)
if(z!=0){
predict<- z[1]
predictW <- lastWordF(predict)
}
if(z==0){
predictW <- cListy[1]
}
}
return(predictW)
}
mytest<- predictW("your home")
predictW <- function(x){
triWx <-c(x) ## input "I did ya"
triWx<- tolower(triWx)
l<- length(unlist(strsplit(triWx, " ")))
if( l == 1 )
{
lastWordF(triWx)
cList <- candiateF(lastWordF(triWx))
predictW <- cList[1]
}
if(l!=1)
{
lastWordF(triWx)
test2x <- lastTwoWordF(triWx)
cListy <- candiateF(lastWordF(triWx))
test3XYbeta<- triTokenF(test2x,cListy)
z <- as.character(test3XYbeta$triToken)
if(length(z)!=0){
predict<- z[1]
predictW <- lastWordF(predict)
}
if(length(z)==0){
predictW <- cListy[1]
}
}
return(predictW)
}
mytest<- predictW("your home")
mytest<- predictW("your home")
mytest<- predictW("home")
mytest<- predictW("In the")
mytest<- predictW("the")
shiny::runApp('~/word-app')
shiny::runApp('~/word-app')
